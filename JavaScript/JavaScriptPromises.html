<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>JS Promises</title>
	<script>
		/*
			Promises
			- Handle asynchronous code
			- Can be used to avoid callback hell scenario (Using promise chaining)
			- Two properties - state and result (result only in case of resolve/rejected)

			Promises States -
			1. Pending
			2. Resolved (Fulfilled)
			3. Rejected


			2 Ways:
			Pending -> Resolved -> Setelled
			Pending -> Rejected -> Setelled

			// Define a promise
			let promise = new Promise ((resolve, reject) => {
				// 'resolve' method is for fulfilling the promise (Can send a resolvedMessage - optional)
				// 'reject' method is for rejecting the promise (Can send a rejectedMessage - optional)
			})

			// Handle a promise
			.then method callback -> For executing in case the promise was resolved 
			(Can have a parameter for resolvedMessage - optional)
			.catch method callback -> For executing in case the promise was rejected 
			(Can have a parameter for rejectedMessage - optional)
		*/

		// let promise = new Promise((resolve, reject) => {
		// 	resolve('Hey, I was resolved!')
		// })

		// promise.then((resolvedMessage) => {
		// 	console.log('Promise was resolved with the message: ' + resolvedMessage)
		// }).catch((rejectedMessage) => {
		// 	console.log('Promise was rejected with the message: ' + rejectedMessage)
		// })

		// Handling rejection is also possible using second callback of .then method
		// promise.then((resolvedMessage) => {
		// 	console.log('Promise was resolved with the message: ' + resolvedMessage)
		// }, (rejectedMessage) => {
		// 	console.log('Promise was rejected with the message: ' + rejectedMessage)
		// })

		// const promise1 = () => {
		// 	return new Promise((resolve, reject) => {
		// 		reject('Hey, I was rejected!')
		// 	})
		// }
		
		// promise1().then((resolvedMessage) => {
		// 	console.log('Promise was resolved with the message: ' + resolvedMessage)
		// }).catch((rejectedMessage) => {
		// 	console.log('Promise was rejected with the message: ' + rejectedMessage)
		// })

		// Promise chaining: (when you return a value from .then() method - returned value again becomes a promise which needs to be handled by .then() chaining)
		// 1. When first .then handler returns another promise which needs to be handled by chaining another .then()
		// 2. Return any data from first .then() and that data can be caught by the second .then() handler which is chained to the first one

		// const promise1 = () => {
		// 	return new Promise((resolve, reject) => {
		// 		setTimeout(() => {
		// 			resolve('A + ')
		// 		}, 2000)
		// 	})
		// } 

		// promise1().then((resolvedMessage) => {
		// 	return resolvedMessage + 'B + '
		// }).then((resolvedMessage) => {
		// 	return resolvedMessage + 'C'
		// }).then((resolvedMessage) => {
		// 	console.log(resolvedMessage)
		// }).catch((rejectedMessage) => {
		// 	console.log('Promise was rejected with the message: ' + rejectedMessage)
		// })
	</script>
</head>
<body>
	
</body>
</html>